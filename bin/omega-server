#!/usr/bin/ruby
# A omega server executable.
# Initializes the various omega subsystems and begins
# listening for requests via all rjr transports.
#
# Send USR1 signal to run backup  operation on all subsytems,
# send USR2 signal to run restore operation on all subsytems,
# sent INT  signal to gracefully terminate server and exit
#
# Flags:
#  -h --help
#
# Copyright (C) 2011-2012 Mohammed Morsi <mo@morsi.org>
# Licensed under the AGPLv3+ http://www.gnu.org/licenses/agpl.txt

require 'rubygems'
require 'optparse'
require 'fileutils'

require 'rjr/nodes/amqp'
require 'rjr/nodes/ws'
require 'rjr/nodes/web'
require 'rjr/nodes/tcp'
require 'rjr/nodes/local'
require 'rjr/nodes/multi'

require 'omega/server/config'
require 'omega/roles'

######################

def setup_signals(config, node)
  # backup on usr1
  Signal.trap("USR1") {
    puts "Backup"
    Dir.mkdir(config.backup_dir) unless File.directory?(config.backup_dir)
    backup_file = "#{config.backup_dir}backup.unv"
    current_backup = "#{backup_file}.#{Time.now.strftime("%Y.%m.%d-%H.%M.%S")}"
    node.invoke('users::save_state', current_backup)
    node.invoke('motel::save_state', current_backup)
    node.invoke('cosmos::save_state', current_backup)
    node.invoke('manufactured::save_state', current_backup)
    FileUtils.rm_f(backup_file) if File.symlink?(backup_file)
    FileUtils.ln_s(File.expand_path(current_backup), backup_file)
  }

  # restore on usr2
  Signal.trap("USR2") {
    puts "Restore"
    current_backup = backup_file = "#{config.backup_dir}backup.unv"
    node.invoke('users::restore_state', current_backup)
    node.invoke('motel::restore_state', current_backup)
    node.invoke('cosmos::restore_state', current_backup)
    node.invoke('manufactured::restore_state', current_backup)
  }

  # halt on int
  Signal.trap("INT") {
    EventMachine.stop
    #multi_node.terminate
  }
end

def main()
  # setup cmd line options
  opts = OptionParser.new do |opts|
    opts.on("-h", "--help", "Print help message") do
       puts opts
       exit
    end
  end

  # parse cmd line
  begin
    opts.parse!(ARGV)
  rescue OptionParser::InvalidOption
    puts opts
    exit
  end

  # load config
  config = Omega::Config.load :node_id => 'omega',
                              :amqp_broker => 'localhost',
                              :ws_host     => 'localhost',
                              :www_host    => 'localhost',
                              :tcp_host    => 'localhost',
                              :ws_port     =>  8080,
                              :www_port    =>  8888,
                              :tcp_port    => '8181',
                              :node_types  => ['amqp', 'tcp', 'ws', 'www', 'local']

  required_atts = :node_id, :amqp_broker, :ws_host, :www_host, :tcp_host, :ws_port, :www_port, :tcp_port, :node_types,
                  :admin_user, :admin_pass, :irc_server, :irc_port, :irc_channel
  unless config.has_attributes? required_atts
     puts "Must specify config options for #{required_atts.inspect}"
     exit
  end

  config.set_config

  # setup rjr nodes
  nodes = []
  config.node_types.each { |nt|
    case nt
    when 'amqp' then
      nodes << RJR::Nodes::AMQP.new(:node_id => config.node_id, :broker => config.amqp_broker)
    when 'ws' then
      nodes << RJR::Nodes::WS.new(:node_id => config.node_id, :host   => config.ws_host, :port => config.ws_port)
    when 'www' then
      nodes << RJR::Nodes::Web.new(:node_id => config.node_id, :host   => config.www_host, :port => config.www_port)
    when 'tcp' then
      nodes << RJR::Nodes::TCP.new(:node_id => config.node_id, :host => config.tcp_host, :port => config.tcp_port)
    when 'local' then
      nodes << RJR::Nodes::Local.new(:node_id => config.node_id)
    end
  }

  multi_node = RJR::Nodes::Multi.new :nodes => nodes

  RJR::Logger.log_level = config[:log_level] || ::Logger::INFO
  #if RJR::Logger.debug?
  #  require 'rjr/inspect'
  #  require 'motel/rjr_inspect'
  #  require 'manufactured/rjr_inspect'
  #  # TODO other subsystems
  #else
    # filter out 'motel::get_location' and 'cosmos::get_entity' requests
    RJR::Logger.add_filter proc { |m| !(m =~ /.*motel::get_location.*/) }
    RJR::Logger.add_filter proc { |m| !(m =~ /.*cosmos::get_resource.*/) }
    RJR::Logger.add_filter proc { |m| !(m =~ /.*get_entit.*/ ) }
    RJR::Logger.add_filter proc { |m| !(m =~ /.*moving location.*/ ) }
    # TODO allow user to add / customize filters via config file (and command line flags?)
  #end

  # setup the omega systems
  multi_node.dispatcher.add_module('users/rjr/init')
  multi_node.dispatcher.add_module('motel/rjr/init')
  multi_node.dispatcher.add_module('cosmos/rjr/init')
  multi_node.dispatcher.add_module('stats/rjr/init')
  multi_node.dispatcher.add_module('manufactured/rjr/init')
  multi_node.dispatcher.add_module('missions/rjr/init')

  # create the default roles
  local_node = RJR::Nodes::Local.new :node_id => 'server_seeder'
  local_node.dispatcher = multi_node.dispatcher
  Omega::Roles::ROLES.keys.collect { |id|
    role = Users::Role.new :id => id
    Omega::Roles::ROLES[id].each { |pe|
      role.add_privilege pe[0], pe[1]
    }
    local_node.invoke('users::create_role', role)
  }

  # create an initial superadmin user
  admin = Users::User.new :id => config.admin_user, :password => config.admin_pass,
                           :registration_code => nil
  local_node.invoke('users::create_user', admin)
  local_node.invoke('users::add_role',    admin.id, 'superadmin')

  # create an initial anonymous user
  anon = Users::User.new :id => config.anon_user, :password => config.anon_pass,
                         :registration_code => nil
  local_node.invoke('users::create_user', anon)
  local_node.invoke('users::add_role',    anon.id, 'anonymous_user')

  setup_signals(config, local_node)
  multi_node.listen
  multi_node.join
end

main()
