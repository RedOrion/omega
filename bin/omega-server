#!/usr/bin/ruby
# A omega server executable.
# Initializes the various omega subsystems and begins
# listening for requests via all rjr transports.
#
# Send USR1 signal to run backup  operation on all subsytems,
# send USR2 signal to run restore operation on all subsytems,
# sent INT  signal to gracefully terminate server and exit
#
# Flags:
#  -h --help
#
# Copyright (C) 2011-2012 Mohammed Morsi <mo@morsi.org>
# Licensed under the AGPLv3+ http://www.gnu.org/licenses/agpl.txt

require 'rubygems'
require 'optparse'
require 'fileutils'
require 'omega'

######################

def setup_signals(config)
  Signal.trap("USR1") {
    puts "Backup"
    Dir.mkdir(config.backup_dir) unless File.directory?(config.backup_dir)
    backup_file = "#{config.backup_dir}backup.unv"
    current_backup = "#{backup_file}.#{Time.now.strftime("%Y.%m.%d-%H.%M.%S")}"
    local_node = RJR::LocalNode.new :node_id => 'admin'
    local_node.invoke_request('motel::save_state', current_backup)
    local_node.invoke_request('cosmos::save_state', current_backup)
    local_node.invoke_request('manufactured::save_state', current_backup)
    local_node.invoke_request('users::save_state', current_backup)
    FileUtils.rm_f(backup_file) if File.symlink?(backup_file)
    FileUtils.ln_s(File.expand_path(current_backup), backup_file)
  }

  Signal.trap("USR2") {
    puts "Restore"
    current_backup = backup_file = "#{config.backup_dir}backup.unv"
    local_node = RJR::LocalNode.new :node_id => 'admin'
    local_node.invoke_request('motel::restore_state', current_backup)
    local_node.invoke_request('cosmos::restore_state', current_backup)
    local_node.invoke_request('manufactured::restore_state', current_backup)
    local_node.invoke_request('users::restore_state', current_backup)
  }

  Signal.trap("INT") {
    EventMachine.stop
    #multi_node.terminate
  }
end

def main()
  # setup cmd line options
  opts = OptionParser.new do |opts|
    opts.on("-h", "--help", "Print help message") do
       puts opts
       exit
    end
  end

  # parse cmd line
  begin
    opts.parse!(ARGV)
  rescue OptionParser::InvalidOption
    puts opts
    exit
  end

  RJR::Logger.log_level = ::Logger::INFO

  config = Omega::Config.load :node_id => 'omega',
                              :amqp_broker => 'localhost',
                              :ws_host     => 'localhost',
                              :www_host    => 'localhost',
                              :tcp_host    => 'localhost',
                              :ws_port     =>  8080,
                              :www_port    =>  8888,
                              :tcp_port    => '8181',
                              :node_types  => ['amqp', 'tcp', 'ws', 'www', 'local']

  required_atts = :node_id, :amqp_broker, :ws_host, :www_host, :tcp_host, :ws_port, :www_port, :tcp_port, :node_types,
                  :admin_user, :admin_pass, :remote_location_manager_user, :remote_location_manager_pass, :remote_cosmos_manager_user, :remote_cosmos_manager_pass,
                  :irc_server, :irc_port, :irc_channel
  unless config.has_attributes? required_atts
     puts "Must specify config options for #{required_atts.inspect}"
     exit
  end

  Users::RJRAdapter.recaptcha_enabled    = config.recaptcha_enabled
  Users::RJRAdapter.recaptcha_priv_key   = config.recaptcha_pub_key
  Users::RJRAdapter.recaptcha_priv_key   = config.recaptcha_priv_key

  Users::RJRAdapter.mediawiki_enabled    = config.mediawiki_enabled
  Users::RJRAdapter.mediawiki_dir        = config.mediawiki_dir

  Users::EmailHelper.email_enabled       = config.email_enabled
  Users::EmailHelper.smtp_host           = config.smtp_host
  Users::EmailHelper.smtp_from_address   = config.smtp_from_address

  Users::ChatProxy.default_irc_server    = config.irc_server
  Users::ChatProxy.default_irc_port      = config.irc_port
  Users::ChatProxy.default_irc_channel   = config.irc_channel

  Users::RJRAdapter.omega_url            = config.omega_url
  Users::RJRAdapter.permenant_users      = config.permenant_users

  Motel::RemoteLocationManager.user      = config.remote_location_manager_user
  Motel::RemoteLocationManager.password  = config.remote_location_manager_pass
  Cosmos::RemoteCosmosManager.user       = config.remote_cosmos_manager_user
  Cosmos::RemoteCosmosManager.password   = config.remote_cosmos_manager_pass

  Motel::RJRAdapter.init
  Users::RJRAdapter.init
  Cosmos::RJRAdapter.init
  Manufactured::RJRAdapter.init

  nodes = []

  config.node_types.each { |nt|
    case nt
    when 'amqp' then
      nodes << RJR::AMQPNode.new(:node_id => config.node_id, :broker => config.amqp_broker)
    when 'ws' then
      nodes << RJR::WSNode.new(:node_id => config.node_id, :host   => config.ws_host, :port => config.ws_port)
    when 'www' then
      nodes << RJR::WebNode.new(:node_id => config.node_id, :host   => config.www_host, :port => config.www_port)
    when 'tcp' then
      nodes << RJR::TCPNode.new(:node_id => config.node_id, :host => config.tcp_host, :port => config.tcp_port)
    when 'local' then
      nodes << RJR::LocalNode.new(:node_id => config.node_id)
    end
  }

  multi_node = RJR::MultiNode.new :nodes => nodes

  # create the default roles
  local_node = RJR::LocalNode.new :node_id => 'server_seeder'
  Omega::Roles::ROLES.keys.collect { |id|
    role = Users::Role.new :id => id
    Omega::Roles::ROLES[id].each { |pe|
      role.add_privilege pe[0], pe[1]
    }
    local_node.invoke_request('users::create_entity', role)
  }

  # create an initial superadmin user
  admin = Users::User.new :id => config.admin_user, :password => config.admin_pass
  local_node.invoke_request('users::create_entity', admin)
  local_node.invoke_request('users::add_role',       admin.id, 'superadmin')

  # create an user for remote location management
  rlm = Users::User.new :id => config.remote_location_manager_user, :password => config.remote_location_manager_password
  local_node.invoke_request('users::create_entity', rlm)
  local_node.invoke_request('users::add_role',       rlm.id, 'remote_location_manager')

  # create an user for remote cosmos management
  rcm = Users::User.new :id => config.remote_cosmos_manager_user, :password => config.remote_cosmos_manager_password
  local_node.invoke_request('users::create_entity', rcm)
  local_node.invoke_request('users::add_role',       rcm.id, 'remote_cosmos_manager')

  setup_signals(config)
  multi_node.listen
  multi_node.join
end

main()
